name: CD - Continuous Deployment

on:
  workflow_run:
    workflows: ["CI/CD Pipeline"]
    types:
      - completed
    branches: [master]
  workflow_dispatch:
    inputs:
      environment:
        description: "Deployment environment"
        required: true
        type: choice
        options:
          - staging
          - production
      version:
        description: "Version tag (optional, defaults to latest)"
        required: false
        type: string

env:
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_CLI_BUILD: 1

jobs:
  # ========================================
  # Pre-deployment Checks
  # ========================================
  pre-deployment-check:
    name: Pre-deployment Validation
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.head_branch == 'master')

    outputs:
      environment: ${{ steps.determine-env.outputs.environment }}
      version: ${{ steps.determine-version.outputs.version }}
      deploy: ${{ steps.determine-env.outputs.deploy }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Determine environment
        id: determine-env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "environment=${{ inputs.environment }}" >> $GITHUB_OUTPUT
            echo "deploy=true" >> $GITHUB_OUTPUT
          else
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "deploy=true" >> $GITHUB_OUTPUT
          fi

      - name: Determine version
        id: determine-version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]] && [[ -n "${{ inputs.version }}" ]]; then
            echo "version=${{ inputs.version }}" >> $GITHUB_OUTPUT
          else
            echo "version=latest" >> $GITHUB_OUTPUT
          fi

      - name: Validate Docker images exist
        run: |
          echo "Validating Docker images for deployment..."
          VERSION="${{ steps.determine-version.outputs.version }}"

          # Check if images exist in Docker Hub
          if ! docker manifest inspect ${{ secrets.DOCKER_USERNAME }}/ai-chatbot-server:${VERSION} > /dev/null 2>&1; then
            echo "âŒ Server image not found: ${{ secrets.DOCKER_USERNAME }}/ai-chatbot-server:${VERSION}"
            exit 1
          fi

          if ! docker manifest inspect ${{ secrets.DOCKER_USERNAME }}/ai-chatbot-client:${VERSION} > /dev/null 2>&1; then
            echo "âŒ Client image not found: ${{ secrets.DOCKER_USERNAME }}/ai-chatbot-client:${VERSION}"
            exit 1
          fi

          echo "âœ… All Docker images validated successfully"

  # ========================================
  # Deploy to Staging
  # ========================================
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: pre-deployment-check
    if: needs.pre-deployment-check.outputs.environment == 'staging' && needs.pre-deployment-check.outputs.deploy == 'true'
    environment:
      name: staging
      url: ${{ steps.deploy.outputs.url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure deployment
        run: |
          echo "ðŸš€ Deploying to STAGING environment"
          echo "Version: ${{ needs.pre-deployment-check.outputs.version }}"
          echo "Commit: ${{ github.sha }}"

      - name: Setup SSH
        if: secrets.STAGING_SSH_KEY != ''
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.STAGING_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.STAGING_HOST }} >> ~/.ssh/known_hosts

      - name: Deploy via SSH
        if: secrets.STAGING_SSH_KEY != ''
        run: |
          ssh -i ~/.ssh/deploy_key ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }} << 'ENDSSH'
            set -e
            cd ${{ secrets.STAGING_DEPLOY_PATH }}
            
            # Pull latest code
            git fetch origin
            git checkout master
            git pull origin master
            
            # Update environment variables
            echo "Updating environment variables..."
            
            # Pull latest Docker images
            docker pull ${{ secrets.DOCKER_USERNAME }}/ai-chatbot-server:${{ needs.pre-deployment-check.outputs.version }}
            docker pull ${{ secrets.DOCKER_USERNAME }}/ai-chatbot-client:${{ needs.pre-deployment-check.outputs.version }}
            
            # Stop existing containers
            docker compose down
            
            # Start new containers
            docker compose up -d
            
            # Wait for health checks
            echo "Waiting for services to be healthy..."
            sleep 10
            
            # Verify deployment
            curl -f http://localhost:3000/api/health || exit 1
            curl -f http://localhost:80 || exit 1
            
            echo "âœ… Staging deployment completed successfully"
          ENDSSH

      - name: Deploy via Docker Compose (Alternative)
        if: secrets.STAGING_SSH_KEY == ''
        run: |
          echo "âš ï¸ SSH deployment not configured. Using alternative deployment method."
          echo "Please configure STAGING_SSH_KEY, STAGING_HOST, STAGING_USER, and STAGING_DEPLOY_PATH secrets."

      - name: Run smoke tests
        id: smoke-tests
        run: |
          echo "Running smoke tests on staging..."

          # Test API health endpoint
          response=$(curl -s -o /dev/null -w "%{http_code}" ${{ secrets.STAGING_URL }}/api/health || echo "000")
          if [ "$response" != "200" ]; then
            echo "âŒ Health check failed with status: $response"
            exit 1
          fi

          echo "âœ… Smoke tests passed"

      - name: Set deployment URL
        id: deploy
        run: |
          echo "url=${{ secrets.STAGING_URL }}" >> $GITHUB_OUTPUT

      - name: Create deployment summary
        run: |
          echo "## ðŸŽ¯ Staging Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ… **Status:** Deployed Successfully" >> $GITHUB_STEP_SUMMARY
          echo "ðŸŒ **URL:** ${{ secrets.STAGING_URL }}" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ·ï¸ **Version:** ${{ needs.pre-deployment-check.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ“ **Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ‘¤ **Deployed by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "â° **Time:** $(date -u)" >> $GITHUB_STEP_SUMMARY

  # ========================================
  # Deploy to Production
  # ========================================
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: pre-deployment-check
    if: needs.pre-deployment-check.outputs.environment == 'production' && needs.pre-deployment-check.outputs.deploy == 'true'
    environment:
      name: production
      url: ${{ steps.deploy.outputs.url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure deployment
        run: |
          echo "ðŸš€ Deploying to PRODUCTION environment"
          echo "Version: ${{ needs.pre-deployment-check.outputs.version }}"
          echo "Commit: ${{ github.sha }}"

      - name: Create backup
        if: secrets.PRODUCTION_SSH_KEY != ''
        run: |
          echo "ðŸ“¦ Creating backup before deployment..."
          ssh -i ~/.ssh/deploy_key ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} << 'ENDSSH'
            set -e
            BACKUP_DIR="/backups/ai-chatbot-$(date +%Y%m%d_%H%M%S)"
            mkdir -p $BACKUP_DIR
            
            # Backup database
            docker exec ai-chatbot-postgres pg_dump -U postgres ai_chatbot > $BACKUP_DIR/database.sql
            
            # Backup uploads
            cp -r ${{ secrets.PRODUCTION_DEPLOY_PATH }}/server/uploads $BACKUP_DIR/
            
            echo "âœ… Backup created at: $BACKUP_DIR"
          ENDSSH

      - name: Setup SSH
        if: secrets.PRODUCTION_SSH_KEY != ''
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

      - name: Deploy via SSH
        if: secrets.PRODUCTION_SSH_KEY != ''
        run: |
          ssh -i ~/.ssh/deploy_key ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} << 'ENDSSH'
            set -e
            cd ${{ secrets.PRODUCTION_DEPLOY_PATH }}
            
            # Pull latest code
            git fetch origin
            git checkout master
            git pull origin master
            
            # Pull latest Docker images
            docker pull ${{ secrets.DOCKER_USERNAME }}/ai-chatbot-server:${{ needs.pre-deployment-check.outputs.version }}
            docker pull ${{ secrets.DOCKER_USERNAME }}/ai-chatbot-client:${{ needs.pre-deployment-check.outputs.version }}
            
            # Zero-downtime deployment with rolling update
            echo "Starting rolling update..."
            
            # Scale up new instances
            docker compose up -d --scale server=2
            sleep 10
            
            # Remove old containers
            docker compose up -d --remove-orphans
            
            # Run database migrations
            docker exec ai-chatbot-server npm run migrate
            
            # Verify deployment
            echo "Verifying deployment..."
            sleep 5
            curl -f http://localhost:3000/api/health || exit 1
            curl -f http://localhost:80 || exit 1
            
            # Clean up old images
            docker image prune -f
            
            echo "âœ… Production deployment completed successfully"
          ENDSSH

      - name: Run comprehensive tests
        id: production-tests
        run: |
          echo "Running comprehensive tests on production..."

          # Test API health
          response=$(curl -s -o /dev/null -w "%{http_code}" ${{ secrets.PRODUCTION_URL }}/api/health || echo "000")
          if [ "$response" != "200" ]; then
            echo "âŒ Health check failed"
            exit 1
          fi

          # Test authentication endpoints
          response=$(curl -s -o /dev/null -w "%{http_code}" ${{ secrets.PRODUCTION_URL }}/api/auth/login -X POST || echo "000")
          if [ "$response" != "400" ] && [ "$response" != "401" ]; then
            echo "âŒ Auth endpoint check failed"
            exit 1
          fi

          echo "âœ… All production tests passed"

      - name: Set deployment URL
        id: deploy
        run: |
          echo "url=${{ secrets.PRODUCTION_URL }}" >> $GITHUB_OUTPUT

      - name: Create deployment summary
        run: |
          echo "## ðŸš€ Production Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ… **Status:** Deployed Successfully" >> $GITHUB_STEP_SUMMARY
          echo "ðŸŒ **URL:** ${{ secrets.PRODUCTION_URL }}" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ·ï¸ **Version:** ${{ needs.pre-deployment-check.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ“ **Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ‘¤ **Deployed by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "â° **Time:** $(date -u)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“Š Deployment Statistics" >> $GITHUB_STEP_SUMMARY
          echo "- Database migrations: Completed" >> $GITHUB_STEP_SUMMARY
          echo "- Health checks: Passed" >> $GITHUB_STEP_SUMMARY
          echo "- Rollback available: Yes" >> $GITHUB_STEP_SUMMARY

      - name: Notify deployment
        if: always()
        run: |
          echo "ðŸ“¢ Notifying team about production deployment..."
          # Add Slack, Discord, or email notification here

  # ========================================
  # Rollback
  # ========================================
  rollback:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    if: failure() && github.event_name == 'workflow_dispatch'
    needs: [deploy-staging, deploy-production]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Determine rollback environment
        id: rollback-env
        run: |
          echo "environment=${{ inputs.environment }}" >> $GITHUB_OUTPUT

      - name: Execute rollback
        run: |
          echo "ðŸ”„ Initiating rollback for ${{ steps.rollback-env.outputs.environment }}..."

          # Add rollback logic here
          # This could include:
          # - Reverting to previous Docker image tags
          # - Restoring database from backup
          # - Rolling back configuration changes

          echo "âš ï¸ Rollback initiated. Please verify system status."

      - name: Verify rollback
        run: |
          echo "Verifying rollback..."
          # Add verification steps

  # ========================================
  # Post-deployment
  # ========================================
  post-deployment:
    name: Post-deployment Tasks
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production]
    if: |
      always() && 
      (needs.deploy-staging.result == 'success' || needs.deploy-production.result == 'success')

    steps:
      - name: Create Git tag
        if: needs.deploy-production.result == 'success'
        uses: actions/checkout@v4

      - name: Tag release
        if: needs.deploy-production.result == 'success'
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"

          VERSION="v$(date +%Y.%m.%d)-$(git rev-parse --short HEAD)"
          git tag -a $VERSION -m "Production deployment $VERSION"
          git push origin $VERSION

          echo "âœ… Created release tag: $VERSION"

      - name: Update deployment documentation
        run: |
          echo "ðŸ“ Updating deployment documentation..."
          # Add logic to update deployment docs or changelog

      - name: Performance monitoring
        run: |
          echo "ðŸ“Š Setting up performance monitoring..."
          # Add APM or monitoring setup

      - name: Final summary
        run: |
          echo "## ðŸŽ‰ Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "All deployment tasks completed successfully!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Next Steps:" >> $GITHUB_STEP_SUMMARY
          echo "- [ ] Verify application functionality" >> $GITHUB_STEP_SUMMARY
          echo "- [ ] Monitor error rates and performance" >> $GITHUB_STEP_SUMMARY
          echo "- [ ] Update team documentation" >> $GITHUB_STEP_SUMMARY
          echo "- [ ] Close related issues/tickets" >> $GITHUB_STEP_SUMMARY
